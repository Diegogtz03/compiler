/* Lexico - Palabras reservadas */

program : 'p' 'r' 'o' 'g' 'r' 'a' 'm';
main : 'm' 'a' 'i' 'n';
var: 'v' 'a' 'r';
end: 'e' 'n' 'd';
int_rw: 'i' 'n' 't';
float_rw: 'f' 'l' 'o' 'a' 't';
void: 'v' 'o' 'i' 'd';
while: 'w' 'h' 'i' 'l' 'e';
do: 'd' 'o';
print: 'p' 'r' 'i' 'n' 't';
if: 'i' 'f';
else: 'e' 'l' 's' 'e';

/* Lexico - Simbolos */

semicolon: ';';
two_dots: ':';
comma: ',';
curly_open: '{';
curly_close: '}';
parenthesis_open: '(';
parenthesis_close: ')';
bracket_open: '[';
bracket_close: ']';
equal: '=';
plus: '+';
minus: '-';
greater_than: '>';
less_than: '<';
not_equal: '!' '=';
mult: '*';
div: '/';

/* Lexico - Constantes */

id : 'a'-'z' {'a'-'z'} { ('_' | 'A'-'Z') ('a'-'z' | 'A'-'Z' | '0'-'9') {'a'-'z' | 'A'-'Z' | '0'-'9'} } ;
myint : '0'-'9' {'0'-'9'} ;
myfloat : '0'-'9' {'0'-'9'} '.' '0'-'9' {'0'-'9'} ;
string : '"' {'a'-'z' | 'A'-'Z'} '"' ;

!whitespace : ' ' | '\t' | '\n' | '\r' ;

/* ------------------------ */
/* Sintaxis */

<< import (
	"compiler/ast"
	"compiler/token"
) >>

Start : Programa ;

Programa : program id semicolon Vars Programa_PR main Body end << ast.CreateProgram($1, $3, $4) >>
  | program id semicolon Programa_PR main Body end << ast.CreateProgram($1, nil, $3) >> ;

Programa_PR : Funcs Programa_PR << append([]*ast.Func{$0.(*ast.Func)}, $1.([]*ast.Func)...), nil >>
  | empty << []*ast.Func{}, nil >> ; 

Vars : var id Vars_PR two_dots Type semicolon Vars_PR_PR << append([]*ast.Vars{ast.CreateVars(append([]string{string($1.(*token.Token).Lit)}, $2.([]string)...), $4)}, $6.([]*ast.Vars)...), nil >> ;

Vars_PR : comma id Vars_PR << append([]string{string($1.(*token.Token).Lit)}, $2.([]string)...), nil >>
  | empty  << []string{}, nil >> ;

Vars_PR_PR : id Vars_PR two_dots Type semicolon Vars_PR_PR << append([]*ast.Vars{ast.CreateVars(append([]string{string($0.(*token.Token).Lit)}, $1.([]string)...), $3)}, $5.([]*ast.Vars)...), nil >>
  | empty << []*ast.Vars{}, nil >> ;

Type : int_rw | float_rw ;



Body : curly_open Body_PR curly_close;

Body_PR : Statement Body_PR
  | empty ;



Statement : Assign << $0, nil >>
  | Condition << $0, nil >>
  | Cycle << $0, nil >>
  | F_call << $0, nil >>
  | Print << $0, nil >>;

Print : print parenthesis_open Expr Print_PR parenthesis_close semicolon
  | print parenthesis_open string Print_PR parenthesis_close semicolon;

Print_PR : comma Expr Print_PR
  | comma string Print_PR
  | empty ;

Assign : id equal Exp semicolon;

Cycle : while parenthesis_open Expr parenthesis_close do Body semicolon;

Condition : if parenthesis_open Expr parenthesis_close Body semicolon
  | if parenthesis_open Expr parenthesis_close Body else Body semicolon;

F_call : id parenthesis_open parenthesis_close semicolon
  | id parenthesis_open Expr F_call_PR parenthesis_close semicolon;

F_call_PR : comma Expr F_call_PR 
  | empty ;






Cte : myint << ast.CreateIntConstant($0) >>
  | myfloat << ast.CreateFloatConstant($0) >>;





Expr : Exp
  | Exp greater_than Exp
  | Exp less_than Exp
  | Exp not_equal Exp;

Exp : Term
  | Term plus Exp
  | Term minus Exp;

Term : Fact
  | Fact mult Term
  | Fact div Term;

Fact : parenthesis_open Expr parenthesis_close
  | Cte
  | id
  | plus id
  | minus id
  | plus Cte
  | minus Cte;






Funcs : void id parenthesis_open parenthesis_close bracket_open Body bracket_close semicolon << ast.CreateFunc($1) >>
  | void id parenthesis_open parenthesis_close bracket_open Vars Body bracket_close semicolon << ast.CreateFunc($1) >>
  | void id parenthesis_open id two_dots Type Funcs_PR parenthesis_close bracket_open Body bracket_close semicolon << ast.CreateFunc($1) >>
  | void id parenthesis_open id two_dots Type Funcs_PR parenthesis_close bracket_open Vars Body bracket_close semicolon << ast.CreateFunc($1) >>;

Funcs_PR : comma id two_dots Type Funcs_PR
  | empty ;